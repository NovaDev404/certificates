name: Check Certificate Status

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  daily-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo (full history)
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Scan cert folders, call API, and update README.md
        env:
          API_URL: "https://tools.nezushub.vip/cert-ios-checker/api/"
          README_PATH: "README.md"
        run: |
          set -euo pipefail
          README="${README_PATH}"
          API="${API_URL}"
          CHANGED=0
          TMPDIR="$(mktemp -d)"
          trap 'rm -rf "$TMPDIR"' EXIT

          echo "Scanning top-level directories for certificate bundles..."

          for d in */; do
            dirname="${d%/}"

            # skip common repo/system dirs
            case "$dirname" in
              .github|.git|node_modules|.vscode) continue ;;
            esac

            p12="$dirname/${dirname}.p12"
            profile="$dirname/${dirname}.mobileprovision"
            passfile="$dirname/password.txt"

            if [[ -f "$p12" && -f "$profile" && -f "$passfile" ]]; then
              echo "Found cert bundle for: $dirname"

              # read first line of password (strip CR)
              password="$(tr -d '\r' < "$passfile" | sed -n '1p')"

              respfile="$TMPDIR/resp_${dirname}.body"
              echo " -> uploading to checker API..."

              # run curl and capture HTTP status; handle network errors gracefully
              if ! http_status=$(curl -s -S -o "$respfile" -w '%{http_code}' -X POST "$API" \
                    -F "file=@${p12}" \
                    -F "secondary_file=@${profile}" \
                    -F "password=${password}" \
                    -H "Accept: application/json"); then
                echo "   Network/curl error when uploading for $dirname — skipping."
                echo "   (see response body if any):"
                cat "$respfile" || true
                continue
              fi

              # If API returned non-200, show body and skip
              if [[ "$http_status" -lt 200 || "$http_status" -ge 300 ]]; then
                echo "   HTTP $http_status returned for $dirname — skipping."
                echo "   Response body:"
                cat "$respfile" || true
                continue
              fi

              # Validate that the response is JSON before using jq
              if ! jq -e . "$respfile" >/dev/null 2>&1; then
                echo "   Response for $dirname is not valid JSON — skipping. Response body:"
                sed -n '1,200p' "$respfile" || true
                continue
              fi

              success=$(jq -r 'if has("success") then .success else false end' "$respfile")
              if [[ "$success" != "true" ]]; then
                err_msg=$(jq -r '.error.message // "unknown error"' "$respfile")
                echo "   API returned failure for $dirname: $err_msg"
                continue
              fi

              certs_match=$(jq -r '(.data.certificate.comparison_data.certificates_match) // false' "$respfile")
              if [[ "$certs_match" != "true" ]]; then
                echo "   Certificates DO NOT match for $dirname — skipping README update."
                continue
              fi

              # extract fields (with safe fallbacks)
              cert_type=$(jq -r '.data.certificate.type // "Unknown Certificate"' "$respfile")
              status_raw=$(jq -r '.data.certificate.certificate_status.status // "Unknown"' "$respfile")
              if [[ "${status_raw,,}" == *"sign"* || "${status_raw,,}" == "signed" ]]; then
                status_icon="**✅ Signed**"
              else
                status_icon="**❌ Revoked**"
              fi

              valid_from_iso=$(jq -r '.data.certificate.certificate_info.validity_period.valid_from // empty' "$respfile")
              valid_to_iso=$(jq -r '.data.certificate.certificate_info.validity_period.valid_to // empty' "$respfile")

              # format dates to DD/MM/YY HH:MM if possible
              valid_from_fmt=""
              valid_to_fmt=""
              if [[ -n "$valid_from_iso" ]]; then
                valid_from_fmt=$(date -d "$valid_from_iso" +"%d/%m/%y %H:%M" 2>/dev/null || echo "$valid_from_iso")
              fi
              if [[ -n "$valid_to_iso" ]]; then
                valid_to_fmt=$(date -d "$valid_to_iso" +"%d/%m/%y %H:%M" 2>/dev/null || echo "$valid_to_iso")
              fi

              echo "   API success & certs match. Type: $cert_type, Status: $status_raw, From: $valid_from_fmt, To: $valid_to_fmt"

              # Replace the README table row whose first column equals the directory name.
              # Use awk with a robust regex to find a line beginning with "| <dirname> |"
              tmp_readme="$TMPDIR/README_${dirname}.md"
              awk -v name="$dirname" -v type="$cert_type" -v status="$status_icon" -v vf="$valid_from_fmt" -v vt="$valid_to_fmt" \
                'BEGIN{found=0; pattern="^\\|[[:space:]]*" name "[[:space:]]*\\|"} \
                 { if ($0 ~ pattern) { printf("| %s | %s | %s | %s | %s |\n", name, type, status, vf, vt); found=1 } else print $0 } \
                 END { if (found==0) exit 2 }' "$README" > "$tmp_readme" && mv "$tmp_readme" "$README" || \
                 ( echo "   WARNING: did not find an existing README row for '\''$dirname'\''. Skipping edit for this entry." && continue )

              CHANGED=1
              echo "   README row updated for $dirname"
            fi
          done

          if [[ "$CHANGED" -eq 1 ]]; then
            echo "Committing README changes..."
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add "$README"
            # If there are staged changes, commit & push
            if git diff --staged --quiet; then
              echo "No staged changes to commit."
            else
              git commit -m "chore: update certificate statuses (automated daily check)"
              git push
              echo "README pushed."
            fi
          else
            echo "No changes detected; nothing to commit."
          fi
